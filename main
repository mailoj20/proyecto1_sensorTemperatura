// Universidad del Valle de Guatemala
// B3023 Digital 2
// Emilio Soria, 221170
// Proyecto 1 - Sensor de Temperatura
// Micro: ESP32 DEV Kit
// Este programa integra un sistema de monitoreo de temperatura

//**************************************************/
// Importación de librerías
//**************************************************/
#include <Arduino.h>
#include <stdint.h>
#include "display_7segmentos.h"
#include "PWM.h"
#include "config.h"

//**************************************************/
// Definiciones
//**************************************************/
#define sensor 36
#define buttonPin 39
#define rgb 23
#define servo 22
#define disp1 14
#define disp2 25
#define disp3 33
#define sA 27
#define sB 32
#define sC 19
#define sD 17
#define sE 16
#define sF 26
#define sG 21
#define sP 18

// Paso 2: Escoger el canal PWM
#define canalPWM 9
// Paso 3: Definir frecuencia de la señal PWM (Hz)
#define freqPWM 50
// Paso 4: Definir resolución del duty cycle (1-16 bits)
#define resPWM 10 // 10 bits

//**************************************************/
// Variables globales
//**************************************************/
float lecturaTemp;
int digits[3];

portMUX_TYPE mux = portMUX_INITIALIZER_UNLOCKED;

struct Button {
    const uint8_t PIN;
    volatile uint8_t numberKeyPresses;
    bool pressed;
};

Button button1 = {buttonPin, 0, false};

//**************************************************/
// Prototipos de función
//**************************************************/
// Paso 1: Definir lo que ocurre durante la interrupción (ISR)
void IRAM_ATTR BTN1_ISR() {
  portENTER_CRITICAL_ISR(&mux);
    button1.numberKeyPresses++;
    button1.pressed = true;
  portEXIT_CRITICAL_ISR(&mux);
}

float getTemperatura(uint8_t);
void numbersToDisplay(float);

//**************************************************/
// Función de configuración
//**************************************************/
void setup() {

  pinMode(sensor, INPUT);

  configurarDisplay(sA,sB,sC,sD,sE,sF,sG,sP);
  configurarPWM(canalPWM, freqPWM, resPWM, servo);
  
  Serial.begin(115200);
  // Paso 2: Adjuntar interrupción al pin
  pinMode(button1.PIN, INPUT_PULLUP);
  attachInterrupt(button1.PIN, BTN1_ISR, FALLING);
}

//**************************************************/
// Loop principal
//**************************************************/
void loop() {
  float lecturaTemp = getTemperatura(sensor);
  Serial.printf("%f°\n", lecturaTemp);
  delay(1000);

  // Usar display
  numbersToDisplay(lecturaTemp);

  digitalWrite(disp1, HIGH);
  digitalWrite(disp2, LOW);
  digitalWrite(disp3, LOW);

  desplegarDisplay(digits[0]);
  desplegarPunto(0);
  delay(5);

  digitalWrite(disp1, LOW);
  digitalWrite(disp2, HIGH);
  digitalWrite(disp3, LOW);

  desplegarDisplay(digits[1]);
  desplegarPunto(1);
  delay(5);

  digitalWrite(disp1, LOW);
  digitalWrite(disp2, LOW);
  digitalWrite(disp3, HIGH);

  desplegarDisplay(digits[2]);
  desplegarPunto(0);
  delay(5);

}

//**************************************************/
// Definición de funciones
//**************************************************/
float getTemperatura(uint8_t analogPin){
  uint16_t valSensor = analogRead(analogPin);
  float voltaje = valSensor * 3.3 / 4096;
  float temperatura = voltaje/0.01;
  return temperatura;
}

// Función para devolver un array con los números que los displays tienen que mostrar
void numbersToDisplay(float valorTemp){
  // Deshacerse del punto decimal y quedarse con un número que contenga los 3 dígitos funcinales para los displays
  int intTemp = (int)(valorTemp*10);
  // Convertir intTemp en string
  String stringTemp = String(intTemp);
    
  // Extraer dígitos y guardarlos en un array de enteros
  for (int i = 0; i < stringTemp.length(); i++){
    char c = stringTemp[i];
    digits[i] = c - '0';
  }
}
